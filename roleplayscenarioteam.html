<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Team Roleplay Scenario | GlassEDGE</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .waiting-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 50;
    }
    #debug-box {
      position: fixed; bottom: 0; left: 0;
      background: rgba(0,0,0,0.8); color: lime; font-size: 12px;
      padding: 8px; max-height: 200px; overflow-y: auto; width: 100%;
      font-family: monospace; z-index: 1000;
    }
    video { width: 100%; background: #000; margin-bottom: 8px; }
  </style>
</head>
<body class="bg-white text-gray-800 font-inter">

<div id="debug-box">DEBUG OUTPUT:<br></div>
<script>
function dbg(msg) {
  console.log(msg);
  const box = document.getElementById('debug-box');
  box.innerHTML += msg + "<br>";
}
dbg("DEBUG: script loaded");

const urlParams = new URLSearchParams(window.location.search);
const eventCode = urlParams.get("event") || "PFN";
const roomCode = urlParams.get("room") || null;
const mode = urlParams.get("mode") || "same";
const isHost = mode === "host";
const isGuest = mode === "guest";
const isSame = mode === "same";
const API_BASE = window.location.origin;
dbg(`DEBUG: Vars -> eventCode=${eventCode}, roomCode=${roomCode}, mode=${mode}, API_BASE=${API_BASE}`);
</script>

<header class="bg-gradient-to-r from-purple-600 to-pink-400 text-white sticky top-0 z-50 shadow-md">
  <div class="max-w-screen-xl mx-auto px-6 py-4 flex justify-between items-center">
    <span class="text-lg font-semibold">GlassEDGE</span>
  </div>
</header>

<div class="flex h-[calc(100vh-64px)] relative">
  <div class="w-2/3 p-8">
    <h2 class="text-2xl font-bold text-purple-600 mb-4 uppercase tracking-wider">
      Event: <span id="event-code">--</span>
    </h2>
    <div class="bg-[#f2f2f2] p-6 rounded-xl">
      <p id="generated-prompt" class="hidden"></p>
    </div>
  </div>
  <div class="w-1/3 p-6 border-l border-gray-200 bg-gray-50 relative">
    <div id="waiting-overlay" class="waiting-overlay hidden">
      <div class="text-center">
        <p id="share-code" class="text-xl mb-4"></p>
        <p>Waiting for second participant to arrive...</p>
      </div>
    </div>
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>
</div>

<script type="module">
dbg("DEBUG: module script started");
document.getElementById("event-code").textContent = eventCode;

const promptElement = document.getElementById("generated-prompt");
const waitingOverlay = document.getElementById("waiting-overlay");
const shareCode = document.getElementById("share-code");
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");

if (isHost && roomCode) {
  waitingOverlay.classList.remove("hidden");
  shareCode.textContent = `Share this code: ${roomCode}`;
  dbg("DEBUG: Host waiting overlay shown");
}

let pc, dataChannel;
let candidateQueue = [];
const remoteStream = new MediaStream();

async function loadPrompt() {
  try {
    dbg("DEBUG: Fetching prompt");
    const res = await fetch(`${API_BASE}/api/generatePrompt`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ eventCode })
    });
    const data = await res.json();
    const prompt = data.prompt || "Failed to load prompt.";
    promptElement.textContent = prompt;
    promptElement.classList.remove("hidden");
    dbg("DEBUG: Prompt loaded -> " + prompt.slice(0,60));

    if (isHost && dataChannel) {
      const send = () => {
        dataChannel.send(JSON.stringify({ type: 'scenario', prompt }));
        dbg("DEBUG: Host sent prompt via data channel");
      };
      if (dataChannel.readyState === "open") send();
      else dataChannel.onopen = send;
    }
  } catch (err) {
    dbg("ERROR: loadPrompt failed -> " + err.message);
  }
}

async function initWebRTC() {
  try {
    dbg(`DEBUG: initWebRTC() fired. isHost=${isHost} isGuest=${isGuest}`);
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = stream;
    localVideo.muted = true;

    if (isSame) {
      dbg("DEBUG: Same device mode - loading prompt");
      await loadPrompt();
      return;
    }

    pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    stream.getTracks().forEach(track => pc.addTrack(track, stream));
    pc.ontrack = e => {
      dbg("DEBUG: Remote track received");
      e.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
      remoteVideo.srcObject = remoteStream;
    };

    pc.onicecandidate = e => {
      if (e.candidate) {
        fetch(`${API_BASE}/api/signal`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode, type: 'candidate', data: e.candidate })
        });
      }
    };

    pc.onconnectionstatechange = () => {
      dbg("DEBUG: Connection state -> " + pc.connectionState);
      if (pc.connectionState === "connected") {
        dbg("DEBUG: Peer connection established");
        waitingOverlay.classList.add("hidden");
        if (isHost) loadPrompt();
      }
    };

    if (isHost) {
      dataChannel = pc.createDataChannel("tdm");
      dataChannel.onmessage = e => {
        const msg = JSON.parse(e.data);
        if (msg.type === 'scenario') {
          promptElement.textContent = msg.prompt;
          promptElement.classList.remove("hidden");
          dbg("DEBUG: Host received prompt via data channel");
        }
      };
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      dbg("DEBUG: Host created offer");
      await fetch(`${API_BASE}/api/signal`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ roomCode, type: 'offer', data: offer })
      });
    }

    if (isGuest) {
      pc.ondatachannel = e => {
        dataChannel = e.channel;
        dataChannel.onmessage = e => {
          const msg = JSON.parse(e.data);
          if (msg.type === 'scenario') {
            promptElement.textContent = msg.prompt;
            promptElement.classList.remove("hidden");
            dbg("DEBUG: Guest received prompt via data channel");
          }
        };
      };
      dbg("DEBUG: Guest joining room");
      await fetch(`${API_BASE}/api/rooms`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'join-room', roomCode })
      });
    }

    pollSignal();
  } catch (err) {
    dbg("ERROR: initWebRTC crashed -> " + err.message);
  }
}

async function pollSignal() {
  try {
    const res = await fetch(`${API_BASE}/api/signal?roomCode=${roomCode}`);
    const { messages } = await res.json();
    for (const msg of messages) {
      if (msg.type === 'offer' && isGuest) {
        dbg("DEBUG: Guest received offer");
        await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
        dbg("DEBUG: Guest set remote description");
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        dbg("DEBUG: Guest created answer");
        await fetch(`${API_BASE}/api/signal`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCode, type: 'answer', data: answer })
        });
        for (const c of candidateQueue) {
          await pc.addIceCandidate(new RTCIceCandidate(c));
        }
        candidateQueue = [];
        dbg("DEBUG: Guest flushed queued ICE candidates");
      }
      if (msg.type === 'answer' && isHost) {
        dbg("DEBUG: Host received answer");
        await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
        dbg("DEBUG: Host set remote description");
        for (const c of candidateQueue) {
          await pc.addIceCandidate(new RTCIceCandidate(c));
        }
        candidateQueue = [];
        dbg("DEBUG: Host flushed queued ICE candidates");
      }
      if (msg.type === 'candidate') {
        dbg("DEBUG: ICE candidate received");
        if (pc.remoteDescription && pc.remoteDescription.type) {
          await pc.addIceCandidate(new RTCIceCandidate(msg.data));
        } else {
          dbg("DEBUG: Candidate queued until remoteDescription set");
          candidateQueue.push(msg.data);
        }
      }
    }
  } catch (err) {
    dbg("ERROR: pollSignal -> " + err.message);
  }
  setTimeout(pollSignal, 2000);
}

initWebRTC();
</script>

</body>
</html>
